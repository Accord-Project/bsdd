#+options: ':nil *:t -:t ::t <:t H:5 \n:nil ^:{} anchor:t arch:headline author:t
#+options: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:t e:t email:nil f:t
#+options: inline:t num:t p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+options: timestamp:nil title:t toc:5 todo:t |:t
#+title: Semantic bSDD: Improvements to bSDD GraphQL, JSON and RDF Representations
#+date: <2023-01-25>
#+author: Vladimir Alexiev, Mihail Radkov, Nataliya Keberle
#+email: vladimir.alexiev@ontotext.com
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 28.1 (Org mode 9.5.2)
#+cite_export:

* Table of Contents                                 :TOC:noexport:
:PROPERTIES:
:TOC:      :include all
:CUSTOM_ID: table-of-contents
:END:

:CONTENTS:
- [[#abstract][Abstract]]
- [[#keywords][Keywords]]
- [[#introduction][Introduction]]
  - [[#bsdd][bSDD]]
  - [[#benefits-of-graphql][Benefits of GraphQL]]
  - [[#original-bsdd-schema-graphql-voyager][Original BSDD Schema: GraphQL Voyager]]
  - [[#graphql-conversion-to-soml-schema][GraphQL Conversion to SOML Schema]]
  - [[#original-vs-refactored-files][Original vs Refactored Files]]
- [[#related-work][Related Work]]
- [[#suggestions-for-improvement][Suggestions for Improvement]]
  - [[#improve-property-names][Improve Property Names]]
  - [[#use-the-same-url-for-data-and-for-web-pages][Use the same URL for Data and for Web Pages]]
  - [[#graphql-implementation-errors][GraphQL Implementation Errors]]
    - [[#non-nullable-classifications][Non Nullable Classifications]]
    - [[#missing-objects][Missing Objects]]
    - [[#classification-childs-nullability][Classification Childs Nullability]]
    - [[#additional-null-issues][Additional Null Issues]]
    - [[#classification-property-values][Classification Property Values]]
    - [[#classification-properties-without-identity][Classification Properties Without Identity]]
  - [[#improve-url-structure-and-consistency][Improve URL Structure and Consistency]]
  - [[#declare-urls-to-be-id-and-use-field-name-id][Declare URLs to be ID and use Field Name id]]
  - [[#all-significant-classes-should-have-url][All Significant Classes Should Have URL]]
  - [[#graphql-arrays-and-nullability][GraphQL Arrays and Nullability]]
  - [[#return-the-same-data-across-apis][Return the Same Data Across APIs]]
  - [[#improve-graphql-results-and-eliminate-errors][Improve GraphQL Results and Eliminate Errors]]
  - [[#improve-relations-between-objects][Improve Relations Between Objects]]
  - [[#property-vs-classificationproperty-use-distinct-urls][Property vs ClassificationProperty: Use Distinct URLs]]
  - [[#improve-the-description-of-local-properties][Improve the Description of Local Properties]]
  - [[#improve-rdf-structure][Improve RDF Structure]]
  - [[#use-class-inheritance][Use Class Inheritance]]
  - [[#add-more-classes-and-relations][Add More Classes and Relations]]
  - [[#add-graphql-pagination][Add GraphQL Pagination]]
  - [[#improve-graphql-searchability][Improve GraphQL Searchability]]
  - [[#eliminate-parallel-links-between-classes][Eliminate Parallel Links Between Classes]]
  - [[#improve-multilingual-support][Improve Multilingual Support]]
  - [[#deprecated-properties][Deprecated Properties]]
  - [[#improve-the-description-of-structured-values][Improve the Description of Structured Values]]
  - [[#better-representation-of-predefined-values][Better Representation of Predefined Values]]
- [[#implementing-improvements][Implementing Improvements]]
  - [[#fetching-bsdd-graphql-json][Fetching bSDD GraphQL JSON]]
  - [[#converting-json-to-raw-rdf-using-sparql-anything][Converting JSON to Raw RDF using SPARQL Anything]]
    - [[#raw-json-example][Raw JSON Example]]
    - [[#raw-rdf-example][Raw RDF Example]]
  - [[#transforming-rdf-using-sparql-update][Transforming RDF using SPARQL Update]]
    - [[#original-rdf-example][Original RDF Example]]
    - [[#refactored-rdf-example][Refactored RDF Example]]
- [[#acknowledgements][Acknowledgements]]
- [[#references][References]]
:END:

* Abstract
:PROPERTIES:
:CUSTOM_ID: abstract
:END:
The buildingSmart Data Dictionary (bSDD) is an important shared resource in the Architecture, Engineering, Construction and Operations (AECO) domain.
It is a collection of datasets ("domains") that define various classifications (objects representing building components, products and materials) and their properties.
bSDD defines a GraphQL API, as well as REST APIs that return JSON and RDF representations.
This improves the interoperability of bSDD and its easier deployment in architectural CAD and other AECO software.

However it appears that the data retrieved via different APIs are not identical by structure, these structural differences are not documented, thus lowering the trust to bSDD data quality.  

We conducted the thorough comparison of the data retrieved and the analysis of the results completeness and the fulfillment of FAIR principles by bSDD. Based on the analysis we propose a set of enhancements to make bSDD data more findable, accessible, interoperable and reusable, and provide a SPARQL endpoint where bSDD data are organized into a Semantic bSDD knowledge graph, are more FAIR and are available for browsing and querying with GraphQL and SPARQL. 

* Keywords
:PROPERTIES:
:CUSTOM_ID: keywords
:END:
Linked building data, buildingSMART Data Dictionary, FAIR data, TODO more 

* Introduction
:PROPERTIES:
:CUSTOM_ID: introduction
:END:

** bSDD
:PROPERTIES:
:CUSTOM_ID: bsdd
:END:
Reusable data dictionaries serving interoperation purposes are widely known in industry, for example, IEC Common Data Dictionary (IEC CDD) [@ieccdd] and eCl@ss[@eclass] - for electronic exchange of digital information across industries, ISO 15926 part 4 Reference Data Libraries [[https://rds.posccaesar.org/]] - for electronic exchange of digital information across process plant industries. bsDD is the solution for the AECO domain.

The buildingSMART Data Dictionary (bSDD) [@buildingsmartinternationalBuildingSMARTDataDictionary] is a multilingual hierarchically structured encyclopedia [@oraskariLiveWebOntology2021] of object concepts and their properties used in building information models (BIM). Predefined by some vendors sets of properties extending common property sets of Industry Foundation Classes (IFC) allow to describe specific domains (e.g. transportation) or specific building elements (e.g. doors, windows, stairs). bSDD is
organised according to the Building Information Modelling methodology defined in ISO 23386 (2020) [@ISO233862020] following the language-independent information model used for the development of dictionaries storing information about construction work defined in ISO 12006-3 (2022) [@ISO1200632022]. 
bSDD was initiated to support improved interoperability in the building and construction industry.
Palos et al. @palosStateoftheartAnalysisProduct2012 noted that bSDD is a very comprehensive solution aiming at provisioning of open complementary product data definitions, identification and distribution methods.
bSDD currently keeps descriptions of nearly 80,000 concepts with translations in multiple languages, with 90+ domains ranging from roads and rails to DIN, Omniclass, Uniclass, IFC with extensions etc thus making it a widely accepted source of BIM-oriented and BIM-based data.
The reference system assigns a Global Unique Identifier (GUID) for all defined terms entered into the system in order to enable data utilization in variety of structured documents and applications.


* Related Work
:PROPERTIES:
:CUSTOM_ID: related-work
:END:

According to buildingSMART technical roadmap [[https://www.buildingsmart.org/about/technical-roadmap/]] bSDD service provides output data in various formats and APIs, including RDF, thus making bSDD content higher reusable in Linked Data ecosystem, particularly with geographical data, regulations, product manufacturer data. However, Pauwels et al. in @pauwelsetal2016 note that there is no standard method to generate RDF graphs from bSDD API. Starting from @beetzInteroperableDataModels2014 where "bSDD vocabulary has been transformed into a configurable RDF dataset. On the meta-model level a number of different modeling approaches ranging from OWL to RDFS and SKOS have been implemented to evaluate the advantages and disadvantages of the respective modeling strategies" the work was continued In @pauwelterkaj2016 a complete translation of IFC from EXPRESS to OWL is presented,however lacking modularity and extensibility inherent to best Semantic Web practices @kebedeIntegrationManufacturersProduct2022. In @oraskariLiveWebOntology2021 it is proposed and implemented to generate from bSDD an OWL representation of a selected IFC element together with its property sets on the fly.    

In the survey @kebedeIntegrationManufacturersProduct2022 discussed is the question where and how the bsDD can fit in the Linked building data (LBD) ecosystem. Authors mention that bsDD has undertaken a new round of development showing a shift towards publishing data classifications and properties as Linked Data

TODO MAYBE: review more ways of representing classes, props, prop sets. Eg IEC CDD (ISO PLIB), eClass...

Admitting the advances of bsDD community at providing data in RDF format we met some issues where accomodating these data for our purposes in the frame of ACCORD project [[https://github.com/Accord-Project/bsdd]], among them are different results obtained with different APIs, multiple URIs for same entities, various GraphQL implementatuon errors. In this paper we discuss these issues and propose a set of technical improvements following the best practices of Semantic Web and linked data to obtain "a semantically better version" of bsDD. We implemented and made available our solution using Ontotext Platform[[https://bsdd.ontotext.com/workbench/graphql]].

Unlike @oraskariLiveWebOntology2021, we preserve the original bSDD structure (Domain, Classification, Property, etc) and only add specific improvements, described below, and convert the whole bSDD at once, taking more attention to preserving FAIR [[@GarijoPoveda2020]] principles. 


** Benefits of GraphQL
:PROPERTIES:
:CUSTOM_ID: benefits-of-graphql
:END:
GraphQL [[https://graphql.com]] as a query language for APIs and a runtime for fulfilling those queries with the existing data has many benefits over the traditional REST APIs: ability to avoid overfetching by specifying exactly which data and in which structure are to be returned from the server; ability to retrieve many resources in a single request; GraphQL service defines a set of types which completely describe the set of possible data queriable with that service. bSDD makes use of [[graphiql]] - a graphical interactive in-browser GraphQL IDE, available at [[https://test.bsdd.buildingsmart.org/graphiql/]]. 
Interactive browsing of GraphQL set of types available for bSDD can be obtained with GraphQL Voyager[[https://github.com/IvanGoncharov/graphql-voyager]] or [[https://ivangoncharov.github.io/graphql-voyager/]]. 

** Original BSDD Schema: GraphQL Voyager
:PROPERTIES:
:CUSTOM_ID: original-bsdd-schema-graphql-voyager
:END:
We investigated original bSDD schema and datasets available at [[https://test.bsdd.buildingsmart.org]] with [[https://rawgit2.com/Accord-Project/bsdd/main/bsdd-graphql-voyager-orig.html][GraphQL Voyager]]. In the Figure 1 the original schema is depicted in class and class+fields views.

Overview (uncheck "Show leaf fields"):

[[bsdd-graphql-voyager-overview.png]] Figure 1a.

[[bsdd-graphql-voyager-Classification-ClassificationProperty.png]] Figure 1b.

As we can see, bSDD has 11 basic object types: Domains, Languages, Countries, Units (of measure), ReferenceDocuments, Classifications, Properties, ClassificationRelations, ClassificationProperties, ClassificationPropertyValues, PropertyValues, PropertyRelations. Properties and ClassificationProperties have most fields the same and differ in five fields: ~connectedPropertyCodes~[String] and ~relations~[PropertyRelation] belongs uniquely to ~Property~, ~isRequired~(Boolean), ~isWritable~(boolean), ~predefinedValue~(String), ~propertySet~(String) and ~symbol~9String) - to ~ClassificationProperty~. 

** GraphQL Conversion to SOML Schema
:PROPERTIES:
:CUSTOM_ID: graphql-conversion-to-soml-schema
:END:

Major goal of this project is to improve the bSDD GraphQL API.
To achieve this, the existing GraphQL schema will be converted to a [[https://platform.ontotext.com/semantic-objects/soml/index.html][SOML schema]]
which then will be manually improved and finally used to generate a better GraphQL API with the help of [[https://platform.ontotext.com/semantic-objects/][Ontotext Platform]].

The repository contains a Python utility script [[./graphql2soml.py][graphql2soml.py]] that can generate a
[[https://platform.ontotext.com/semantic-objects/soml/index.html][SOML schema]] from a given GraphQL endpoint.

Executing this script produces two files in the repository:

- [[./bsdd-graphql-schema-orig.json][bsdd-graphql-schema-orig.json]] - JSON response of the GraphQL introspection
- [[./bsdd-graphql-soml-orig.yaml][bsdd-graphql-soml-orig.yaml]] - SOML schema produced from the introspection

The generated SOML schema is valid and can be used immediately. However, there are issues inherited from the GraphQL schema which are described later.
The purpose of the generated SOML schema is to serve as a starting point (instead of starting from scratch) for resolving the issues and improving the schema.
Once this is done, the resulting schema will be saved in [[./bsdd-graphql-soml-refact.yaml][bsdd-graphql-soml-refact.yaml]].

*** GraphQL Data Dumps

The repository includes a Python script ~bsdd2json.py~ that can connect to the bSDD GraphQL API and export all objects in the
GraphQL schema as JSONs including domains, classifications, classification properties etc.

The exported data will be located under the ~data/~ directory once the script is executed. Running this script takes around ~10 hours due to
the large quantity of classifications and classification properties in the GraphQL API.

The overall process is of the script is

- Exports all "root" types with their complete information except relations (object properties)
  - bSDD domains in ~data/domains.json~ (~Domain~ in GraphQL)
  - Countries in ~data/domains.json~ (~Country~ in GraphQL)
  - Languages in ~data/languages.json~ (~Language~ in GraphQL)
  - Measurements units in ~data/units.json~ (~Unit~ in GraphQL)
  - Reference documents in ~data/reference_documents.json~ (~ReferenceDocument~ in GraphQL)
- For each exported domain, it creates a sub directory and exports all classification in that domain in separate JSONs (~Classification~ in GraphQL)
- Collects all unique classification properties, tries to resolve them as global properties and finally exports them in ~properties.json~ (~Property~ in GraphQL)

*** Exporting Data

The repository includes a Python script ~bsdd_export.py~ which works with the GraphQL queries within the ~graphql/~ folder.
It can invoke given query with or without variables and return the response to the user in JSON. To work with the script we need to create a virtual Python enthronement:

- Create a virtual environment with ~python3.9 -m venv .venv~
- Activate it ~source .venv/bin/activate~
- Install the required libraries ~pip install -r requirements.txt~

Then, we can ask for particular types. Here are several examples: 

Get all the domains:

#+begin_src bash
python bsdd_export.py getDomains -o domains.json
#+end_src

Get a particular domain:

#+begin_src bash
python bsdd_export.py getDomain -v "URI=https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3" -o ifc-4.3.json
#+end_src

** Original vs Refactored Files
:PROPERTIES:
:CUSTOM_ID: original-vs-refactored-files
:END:
bsdd-graphql-voyager-orig.html
bsdd-graphql-voyager-refact.html

[[graphql-IntrospectionQuery.graphql]]

bsdd-graphql-schema-orig.json
bsdd-graphql-soml-orig.json
bsdd-graphql-soml-orig.yaml
bsdd-graphql-soml-refact.yaml

IFC-cableSegment-rest-orig.json
IFC-cableSegment-graphql-orig.json
IFC-cableSegment-orig.ttl
IFC-cableSegment-refact.ttl

* Suggestions for Improvement
:PROPERTIES:
:CUSTOM_ID: suggestions-for-improvement
:END:

** Return the Same Data Across APIs
:PROPERTIES:
:CUSTOM_ID: return-the-same-data-across-apis
:END:
We have compared three representations returned by the bSDD server:
- JSON from the GraphQL API
- JSON from the REST (entity) API
- RDF  from the REST (entity) API

We selected the most filled objects of each class (i.e. objects with maximum fields filled) and compared the fields in each of the three APIs, see [[https://github.com/Accord-Project/bsdd/tree/main/samples/1-*.json]]

There are differences and omissions in some of the formats, as described in the table below.
It would be better to return the same content in each of the formats.


| Classification/property | GraphQL      | JSON API                                   | RDF API                |comment
|------------------------+--------------+--------------------------------------------+------------------------+--------------------------------------------|
| Classification/childs  | childs       | parentClassificationReference.namespaceUri | NONE                   | GraphQL points to child, JSON points to parent (1)
| Classification/domain  | NONE         | NONE                                       | bsdd:Domain            | GraphQL and JSON API do not return property ~domain~ whereas RDF API returns it  |
| Classification/domainNamespaceUri | NONE | domainNamespaceUri | NONE | GraphQL and RDF API do not return property ~domainNamespaceUri~ |
| Property/domain  | NONE         | NONE                                       | bsdd:Domain            | GraphQL and JSON API do not return property ~domain~ whereas RDF API returns it  |
| Property/domainNamespaceUri | NONE | domainNamespaceUri | NONE | GraphQL and RDF API do not return property ~domainNamespaceUri~ |
| ClassificationProperty |              |                                            |                        | TODO: ClassificationProperty possesses 5 unique fields: ~isRequired~, ~isWritable~, ~predefinedValue~, ~propertySet~, ~symbol~. Property has uniquely ~connectedPropertyCodes~ and ~relations~ (TODO: think over: GraphQL and JSON overload the URL and use it for both ClassificationProperty and Property (2)            |
| link to general property   | namespaceUri | namespaceUri                               | propertyNamespaceUri   | GraphQL and JSON have no real link, just the overloaded URL. The RDF prop is a string, should be URL (3) |
| link to classification     |              |                                            | classificationProperty | RDF prop is misnamed, should be "classification" (4) |
|                            |              |                                            |                        |                                                                                                          |

Illustrations of the points above:
- (1) GraphQL field ~childs~ appears when one queries for ~classification (namespaceUri:"...", includeChilds:true)~.
    It includes a list of children classifications but with simple properties only.
#+begin_src
{
  classification(namespaceUri: "https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcWall", includeChilds: true) {
    name
    code
    namespaceUri
    childs {
      classificationType
      name
    }
  }
}
#+end_src
results in
#+begin_src json
{
  "data": {
    "classification": {
      "name": "IfcWall",
      "code": "IfcWall",
      "namespaceUri": "https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcWall",
      "childs": [
        {
          "classificationType": "CLASS",
          "name": "IfcWallStandardCase",
        },
        {
          "classificationType": "CLASS",
          "name": "IfcWall.ELEMENTEDWALL",
        },
        ...
        }}}
#+end_src

- (1) JSON includes the inverse link (from child to parent), e.g. when one fetches the subclass ~IfcCableSegmentCABLESEGMENT~, one gets a parent link to ~IfcCableSegment~
#+begin_src json
// curl -s https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegmentCABLESEGMENT
{
  "referenceCode": "IfcCableSegmentCABLESEGMENT",
  "parentClassificationReference": {
    "namespaceUri": "https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegment",
#+end_src
- (2,3) In GraphQL and JSON payload, a ~ClassificationProperty~ does not have a distinct URL, and cannot be obtained separately from the ~Classification~ in which it lives.
  As a consequence, ClassificationProperties are not considered as first-class entities
#+begin_src json
// curl -s https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegmentCABLESEGMENT
{
  "referenceCode": "IfcCableSegmentCABLESEGMENT",
  "classificationProperties": [
    {
      "name": "ACResistance",
      "propertyCode": "ACResistance",
      "propertyDomainName": "IFC",
      "propertyNamespaceUri": "https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/prop/ACResistance",
#+end_src

- (3) RDF includes the following attribute (string). Instead, it should be a relation (object property), e.g.  ~bsdd:property <prop/ACResistance>~
#+begin_src turtle
@base <https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/>.
<class/IfcCableSegmentCABLESEGMENT/ACResistance>
  bsdd:PropertyNamespaceUri "https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/prop/ACResistance".
#+end_src

- (4) RDF includes the following relation. The source is a ~ClassificationProperty~ and the target is a ~Classification~, so the relation should be named ~classification~
#+begin_src turtle
@base <https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/>.
<class/IfcCableSegmentCABLESEGMENT/ACResistance>
  bsdd:ClassificationProperty <class/IfcCableSegmentCABLESEGMENT>.
#+end_src

** Improve Property Names
:PROPERTIES:
:CUSTOM_ID: improve-property-names
:END:
Property names should conform to naming conventions and be spelled consistently
- Property (field) names should be spelled in singular, even when they refer to an array.
  The arity is reflected in the property kind, e.g. in GraphQL that's ~SCALAR~ vs ~ARRAY~.
  For example, ~String~ is a scalar string, whereas ~[String]~ is an array of strings.
- The GraphQL and JSON field ~childs~ should be spelled properly as ~children~ (unless it's spelled in singular, see above)
- RDF properties should conform to the ~lowerCamelCase~ convention, i.e. start with a lowercase letter.
  Most ontologies conform to this convention, eg see the [[https://schema.org/docs/styleguide.html][Schema.org Styleguide]]
- Equivalent properties should be named the same in all cases.
  For example, TODO
- ~namespaceUri~ is a misnomer since "namespace" means a set of URIs sharing the same prefix, but most bSDD URIs are *single* URIs.
  URI is a general term that includes both URNs (non-resolvable) and URLs (resolvable).
  According to Linked Data principles, it is better to use resolvable URLs.
  Also see sec [[*All Significant Classes Should Have URL]] for more considerations about this field.
- RDF properties should use one consistent namespace.
  Most props use ~bsdd: <http://bsdd.buildingsmart.org/def#>~,
  except ~hasReference~, which uses a different namespace:
  ~<http://bsdd.buildingsmart.org/relation/def#>~.
  You can see this problem by fetching:
: curl -s -H Accept:text/turtle  https://identifier.buildingsmart.org/uri/bs-agri/fruitvegs-1.0/class/apple

** Use the same URL for Data and for Web Pages
:PROPERTIES:
:CUSTOM_ID: use-the-same-url-for-data-and-for-web-pages
:END:
bSDD has implemented "entity URLs", i.e. for each kind of entity it can return its data in JSON or RDF:
#+begin_src
curl -s                      https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegmentCABLESEGMENT
curl -s -Haccept:text/turtle https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegmentCABLESEGMENT
#+end_src
Note: to pretty-print the JSON, add this to the end of the command: ~| jq .~

The same URL can be used to get a static web page in the browser:
https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegmentCABLESEGMENT

[[IFC-class-cableSegment-web.png]]

However, the interactive [[https://search.bsdd.buildingsmart.org][bSDD Search]] UI uses a different URL that returns slightly different information:
https://search.bsdd.buildingsmart.org/Classification/Index/58453

[[IFC-class-cableSegment-search.png]]

Is there need for two different web pages showing nearly the same info?
We think that with some modest change in technology, the Search UI can use the first (semantic) URL directly, instead of an internal (non-semantic) "Index" URL.
Otherwise there is danger that people will start copying these non-semantic URLs in communication, and in AECO data.

** GraphQL Implementation Errors
:PROPERTIES:
:CUSTOM_ID: graphql-implementation-errors
:END:

*** Non Nullable Classifications
:PROPERTIES:
:CUSTOM_ID: non-nullable-classifications
:END:
Querying all domains including their classifications results in a GraphQL error.
This is due to ~classificationSearch~ being marked as non nullable but the backend API is returning ~null~.

#+begin_src graphql
query getDomainsAndClassifications {
  domains {
    id: namespaceUri
    classificationSearch {
      id: namespaceUri
    }
  }
}
#+end_src
will result into
#+begin_src json
{
  "errors": [
    {
      "message": "Error trying to resolve field 'classificationSearch'.",
      "locations": [
        {
          "line": 4,
          "column": 5
        }
      ],
      "path": [
        "domains",
        67,
        "classificationSearch"
      ],
      "extensions": {
        "code": "NULL_REFERENCE",
        "codes": [
          "NULL_REFERENCE"
        ]
      }
    }
  ],
  "data": {
    "domains": [
      {
...
#+end_src

You can test the query [[https://test.bsdd.buildingsmart.org/graphiql/?query=query%20getDomainsAndClassifications%20%7B%0A%20%20domains%20%7B%0A%20%20%20%20id%3A%20namespaceUri%0A%20%20%20%20classificationSearch%20%7B%0A%20%20%20%20%20%20id%3A%20namespaceUri%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A&operationName=getDomainsAndClassifications][here]].

*** Missing Objects
:PROPERTIES:
:CUSTOM_ID: missing-objects
:END:
The GraphQL API returns domains that cannot be queried independently, one such domain is ~http://identifier.buildingsmart.org/uri/spr/spr-cfhios-0.1~.

#+begin_src graphql
{
  domains {
    id: namespaceUri
  }
  domain(namespaceUri: "http://identifier.buildingsmart.org/uri/spr/spr-cfhios-0.1") {
    id: namespaceUri
  }
}
#+end_src

The second response for ~domain~ will be ~null~ although the domain has been returned in the ~domains~ response.
This is probably the same issue as the previous.

You can test the query [[https://test.bsdd.buildingsmart.org/graphiql/?query=%7B%0A%20%20domains%20%7B%0A%20%20%20%20id%3A%20namespaceUri%0A%20%20%7D%0A%20%20domain(namespaceUri%3A%20%22http%3A%2F%2Fidentifier.buildingsmart.org%2Furi%2Fspr%2Fspr-cfhios-0.1%22)%20%7B%0A%20%20%20%20id%3A%20namespaceUri%0A%20%20%7D%0A%7D][here]].

*** Classification Childs Nullability
:PROPERTIES:
:CUSTOM_ID: classification-childs-nullability
:END:
Similar to the first issue, ~Classification.childs~ is defined with type ~[Classification]~ which means it is OK to be ~null~.
However, unless ~includeChilds:true~ is provided as input argument in ~classification~, queries will fail with NULL_REFERENCE errors thus
breaking GraphQL spec compliance.

#+begin_src json
{
  "errors": [
    {
      "message": "Error trying to resolve field 'childs'.",
      "locations": [
        {
          "line": 71,
          "column": 5
        }
      ],
      "path": [
        "classification",
        "childs"
      ],
      "extensions": {
        "code": "NULL_REFERENCE",
        "codes": [
          "NULL_REFERENCE"
        ]
      }
    }
  ],
  "data": {
    "classification": {
    ...
#+end_src

You can test such a query [[https://test.bsdd.buildingsmart.org/graphiql/?query=query%20getClassificationProperties%20%7B%0A%20%20classification(namespaceUri%3A%20%22https%3A%2F%2Fidentifier.buildingsmart.org%2Furi%2Fbuildingsmart%2Fifc-4.3%2Fclass%2FIfcAirTerminalBox%22%2C%20includeChilds%3A%20false)%20%7B%0A%20%20%20%20id%3A%20namespaceUri%0A%20%20%20%20childs%20%7B%0A%20%20%20%20%20%20id%3A%20namespaceUri%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D&operationName=getClassificationProperties][here]]

*** Additional Null Issues
:PROPERTIES:
:CUSTOM_ID: additional-null-issues
:END:

- There are classifications for which some of the properties cannot be returned and this results in ~NULL_REFERENCE~ errors although the fields are nullable.
  #+begin_src graphql
  query getClassificationProperties {
    classification(namespaceUri: "https://identifier.buildingsmart.org/uri/molio/cciconstruction-1.0/class/L-NAA") {
      name
      properties {
        name
      }
    }
  }
  #+end_src
  This query will return the classification along with 4 out of 5 properties, the 5th property will be ~null~.
  You can test the query [[https://test.bsdd.buildingsmart.org/graphiql/?query=query%20getClassificationProperties%20%7B%0A%20%20classification(namespaceUri%3A%20%22https%3A%2F%2Fidentifier.buildingsmart.org%2Furi%2Fmolio%2Fcciconstruction-1.0%2Fclass%2FL-NAA%22)%20%7B%0A%20%20%20%20name%0A%20%20%20%20properties%20%7B%0A%20%20%20%20%20%20name%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A][here]].

*** Classification Property Values
:PROPERTIES:
:CUSTOM_ID: classification-property-values
:END:

The classification properties have ~allowedValues~ and ~possibleValues~ as fields which are objects of type ~ClassificationPropertyValue~,
for example:
#+begin_src json
[
  {
    "namespaceUri": null,
    "code": "DUALDUCT",
    "description": null,
    "sortNumber": null
  },
  {
    "namespaceUri": null,
    "code": "MULTIZONE",
    "description": null,
    "sortNumber": null
  },
  {
    "namespaceUri": null,
    "code": "NOTKNOWN",
    "description": null,
    "sortNumber": null
  },
  {
    "namespaceUri": null,
    "code": "OTHER",
    "description": null,
    "sortNumber": null
  },
  {
    "namespaceUri": null,
    "code": "SINGLEDUCT",
    "description": null,
    "sortNumber": null
  },
  {
    "namespaceUri": null,
    "code": "UNSET",
    "description": null,
    "sortNumber": null
  }
]
#+end_src
None of the inspected values have ~namespaceUri~, ~description~ or ~sortNumber~.

The classification properties has a ~predefinedValue~ field but it is of type ~String~ instead of utilizing ~ClassificationPropertyValue~.

*** Classification Properties Without Identity
:PROPERTIES:
:CUSTOM_ID: classification-properties-without-identity
:END:

Every classification property is scoped within the owning classification and it may include data that is applicable only within that classification.
They include a ~namespaceUri~ field but this is the global property identifier, not one within the classification and therefore they cannot be
uniquely identified and located in the scope of the classification.

For example, the following classification:
#+begin_src graphql
query getClassificationProperties {
  classification(namespaceUri: "https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegmentCABLESEGMENT") {
    namespaceUri
    properties {
      namespaceUri
    }
  }
}
#+end_src
will return
#+begin_src json
{
  "data": {
    "classification": {
      "namespaceUri": "https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegmentCABLESEGMENT",
      "properties": [
        {
          "namespaceUri": "https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/prop/ACResistance"
        },
        {
          "namespaceUri": "https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/prop/CurrentCarryingCapacity"
        },
  ...
#+end_src

This is the case with responses from the JSON API as well, the properties have no unique identifier. However, the RDF TTL representation is the opposite.
Requesting ~text/turtle~ from the JSON API will return the following part:

#+begin_src turtle
<https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegmentCABLESEGMENT/ACResistance> bsdd:ClassificationProperty <https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegmentCABLESEGMENT>;
#+end_src

It can be seen that ~ACResistance~ is scoped to the ~IfcCableSegmentCABLESEGMENT~ classification and thus it can be easily identified and located.
This difference leads to very inconsistent results from the different APIs.

** Improve URL Structure and Consistency
:PROPERTIES:
:CUSTOM_ID: improve-url-structure-and-consistency
:END:
- Almost all domain URLs have the same structure: ~https://identifier.buildingsmart.org/uri/<org>/<domain>-<ver>~.
  There are only 2 exceptions:
#+begin_src
http://otl.amsterdam.nl
http://rdf.vegdata.no/V440/v440-owl
#+end_src

- TODO: org vs domain vs domain version.
  Refer to URL Hackability in LOD Patterns book
  https://patterns.dataincubator.org/book/hierarchical-uris.html
- In some cases the org name doesn't quite mesh with the domain name, perhaps due to the way bSDD allocates org identifiers to bSDD contributors
  - bim-de/DINSPEC91400: the publisher of this spec is DIN (the German standards organization), not the ~bim-de~ initiative
  - digibase/volkerwesselsbv: [[https://www.bimregister.nl/actueel/video/author/89-delanokenepa?start=250][bimregister.nl news from 2018]] suggest that ~digibase~ is a new company/initaitive within Volker Wessel
  - digibase/nen2699: the publisher of this spec is NEN (the Netherlands standards organization), not the ~digibase~ company/initiative
  - digibase/digibasebouwlagen: perhaps the org name ~digibase~ should not be repeated as prefix of the domain ~bouwlagen~ (building layers)
- A few domains use ~http~ whereas all others use ~https~. All modern servers prefer ~https~ due to its better security.
#+begin_src
http://identifier.buildingsmart.org/uri/spr/spr-cfhios-0.1
http://otl.amsterdam.nl
http://rdf.vegdata.no/V440/v440-owl
#+end_src

** Declare URLs to be ~ID~ and use Field Name ~id~
:PROPERTIES:
:CUSTOM_ID: declare-urls-to-be-id-and-use-field-name-id
:END:
The [[https://spec.graphql.org/draft/#sec-ID][GraphQL specification sec 3.5.5. ID]] states
"The ~ID~ scalar type represents a unique identifier,
often used to refetch an object or as the key for a cache".
This datatype is like String, but is specially designated to be used for identifiers.

Furthermore, the [[https://graphql.org/learn/global-object-identification/#node-interface][Global Object Identification Guide for GraphQL]] recommends
that states that objects should have a field ~id~ that returns non-null ~ID!~
(through the ~Node~ interface).
The ~id~ should be a "globally unique identifier" for the object,
and given just this ~id~, the server should be able to refetch the object.

Most GraphQL implementations call this field simply ~id~,
whereas bSDD, uses unwieldy property names like ~namespaceUri~.

** All Significant Classes Should Have URL
:PROPERTIES:
:CUSTOM_ID: all-significant-classes-should-have-url
:END:
Following the previous section, all significant classes should have ~ID~,
(which in the case of linked data is really a URL).

However, many bSDD classes don't have such a field:
- ~Domain, Property, Classification~ do have ~namespaceUri~
- ~Country, Language, Unit~ don't have an ID but have a field (~code, isocode~)
  that can be used to make an ID, when prepended with an appropriate prefix.
  However, ~Unit.code~ is not always fit to be used in a URL
- ~ClassificationProperty~ doesn't have an ID in GraphQL.
  We follow the bSDD RDF representation and assign a URL
  from the URL of the owning object (~Classification~) and its own ~propertyCode~:
:  Classification.namespaceUri+"/"+propertyCode
- ~PropertyValue, ClassificationPropertyValue~ has ~namespaceUri~
  but it's optional and is almost never filled.
  We assign URL similarly to the previous case:
  from the URL of the owning object and its own ~value~:
: Property.namespaceUri+"/"+value OR
: ClassificationProperty.namespaceUri+"/"+value
- The following classes have no fields suitable to make a URL, so they remain blank nodes:
  - ~ReferenceDocument~: only ~name, title, date~
  - ~ClassificationRelation~: a pair of ~related~ Classifications, no own URL
  - ~PropertyRelation~: a pair of ~related~ Properties, no own URL

Unfortunately, the bSDD GraphQL endpoint doesn't

TODO: this is not in the RDF API, so it's test junk. Remove this complaint below:
For example, the classification indicated below has ClassificationProperties with no ~propertyCode~
#+begin_src json
"namespaceUri": "https://identifier.buildingsmart.org/uri/uniweimar/uniweimar-0.1/class/Nondestructive",
"properties": [
  {
    "description": "Identifier of the tested structure",
    "isRequired": true,
    "isWritable": true,
    "predefinedValue": null,
    "propertySet": "Single",
    "__typename": "ClassificationProperty"
  }...]
#+end_src

** GraphQL Arrays and Nullability
:PROPERTIES:
:CUSTOM_ID: graphql-arrays-and-nullability
:END:
TODO: all of  [Classification], [Classification!], [Classification]!, [Classification!]! are different. Their spec [Classification] allows [null,null,null] as an xanswer

** Improve GraphQL Results and Eliminate Errors
:PROPERTIES:
:CUSTOM_ID: improve-graphql-results-and-eliminate-errors
:END:
# This is from counting in Ontotext\project\ACCORD\bSDD\data:
# - Source (Misho): classifications_export.log, domain_classifications.log
# - Count (Vlado): domain-count.txt
# - Gsheet (Vlado): https://docs.google.com/spreadsheets/d/1z_NRMlExlVuqWhBbSErQ9iiDBY4O_fKMd3avV3-NCmo/edit#gid=2024352985

As of Dec 2022, the [[https://test.bsdd.buildingsmart.org/graphql/][bSDD Test GraphQL API]] returns the following results.
- TODO Misho: can you access the Production GraphQL secured endpoint: https://api.bsdd.buildingsmart.org/graphqls/ ?
Some of them can be improved as described below.

The GraphQL API returns 90 domains.
The distribution of classifications per domain is as follows:
| from |   to | count | note                                                                                   |
|------+------+-------+----------------------------------------------------------------------------------------|
|    0 |    0 |    12 | 12 domains have no data at all (no classifications)                                    |
|    1 |    9 |    28 |                                                                                        |
|   11 |   99 |    19 |                                                                                        |
|  100 |  499 |    15 |                                                                                        |
|  500 |  999 |     3 |                                                                                        |
| 1000 | 4999 |     9 |                                                                                        |
| 5000 | 5000 |     1 | Has more than 5000, but returns only 5000 due to lack of pagination in the GraphQL API |

Domains with no classifications:
#+begin_src
http://identifier.buildingsmart.org/uri/spr/spr-cfhios-0.1
https://identifier.buildingsmart.org/uri/ArcDox/ArcDox-1.0
https://identifier.buildingsmart.org/uri/BBRI/BBRI-0.1
https://identifier.buildingsmart.org/uri/FCSI/keq-0.1
https://identifier.buildingsmart.org/uri/MTR/MTR-1
https://identifier.buildingsmart.org/uri/bimeta/bimeta-0.1
https://identifier.buildingsmart.org/uri/bimlib/bimlib-ru-temp-1
https://identifier.buildingsmart.org/uri/buildingsmart/demo-2-1.1
https://identifier.buildingsmart.org/uri/csi/omniclass-1
https://identifier.buildingsmart.org/uri/ethz/hosszu-0.1
https://identifier.buildingsmart.org/uri/growingcircle/transsmart-0.1
https://identifier.buildingsmart.org/uri/ifcrail/ifcrail-0.1
#+end_src

One domain has more than 5000 classifications, but returns only 5000 due to lack of pagination in the GraphQL API:
#+begin_src
https://identifier.buildingsmart.org/uri/nbs/uniclass2015-1
#+end_src

"Classification with namespace URI 'https://identifier.buildingsmart.org/uri/fvhf/vhf-0.002/class/G5.04.01' not found"
]

TODO Misho: add more

** Improve Relations Between Objects
:PROPERTIES:
:CUSTOM_ID: improve-relations-between-objects
:END:
BSDD includes numerous string attributes (codes or URLs) that should be converted to relations (object fields) in order to improve the connectedness of the GraphQL graph.
- ~ClassificationRelation~ and ~PropertyRelation~ do not have any outgoing relations, instead they use strings (e.g. ~relatedPropertyUri~), thus blocking further GraphQL navigation
- There are a number of unused classes (~Country, Language, ReferenceDocument, Unit~).
  Instead of relations pointing to these classes, the other classes have strings that represent the same information
Problems related to this approach:
- One cannot easily navigate in the GraphQL graph.
  E.g. to find the country name for ~countriesOfUse: ["BG"]~, one needs to make a second query,
  get all countries, and look for that code.
- It represents data denormalization that creates opportunities for data inconsistency or redundancy,
  e.g. if ~countriesOfUse~ includes a code "XX" that is not defined in ~Country~, is that a mistake, or is ~Country~ just an advisory table?

TODO explain more.


Here is a list of all strings that are candidates to be converted to objects:
- ~countriesOfUse~: array of country code strings, should become array of relations to ~Country~
- ~documentReference~: a string, and it's unclear whether it should be the URL of a ~ReferenceDocument~, a bibliographic reference, a title or some other free text.
  Should become relation to ~ReferenceDocument~
- ~relatedIfcEntityNames~: since IFC is present as a bSDD Domain, could be converted to a relation to the respective IFC Classification

  TODO: PropSet should be made an entoity, it's too important to be a mere string

** Property vs ClassificationProperty: Use Distinct URLs
:PROPERTIES:
:CUSTOM_ID: property-vs-classificationproperty-use-distinct-urls
:END:
~Property~ and ~ClassificationProperty~ are two different classes, but the latter does not have a distinct URL in GraphQL and JSON.
We can say that the same URL is overloaded to identify entities of both classes.

~ClassificationProperty~ is identified only in RDF since this format forces one to use different identities for different nodes:
#+begin_src turtle
<https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegmentCABLESEGMENT/ACResistance>
  bsdd:ClassificationProperty <https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegmentCABLESEGMENT>;
  bsdd:PropertyDomainName "IFC";
  bsdd:PropertyNamespaceUri "https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/prop/ACResistance".
#+end_src

~ClassificationProperty~ are thus "second class" entities and are not returned separately by the JSON or RDF entity API,
but only as part of the respective ~Classification~:
#+begin_src
curl https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegmentCABLESEGMENT/ACResistance
{"":["Classification with namespace URI
 'https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegmentCABLESEGMENT/ACResistance'
  not found"]}
#+end_src

** Improve the Description of Local Properties
:PROPERTIES:
:CUSTOM_ID: improve-the-description-of-local-properties
:END:
Perhaps because there is no clearly defined distinction between global properties (~Property~) and local properties (~ClassificationProperty~)
and no rules which attributes are inherited from one to the other,
some local properties are not properly described.
For example, let's look at the local property ~Status~ in classification [[https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcAirTerminalBox][IfcAirTerminalBox]]:

#+begin_src json
      "name": "Status",
      "description": "The status currently assigned to the permit.",
      "propertyCode": "Status",
      "propertyNamespaceUri": "https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/prop/Status",
      "propertySet": "Pset_AirTerminalBoxTypeCommon",
#+end_src

The local definition refers to an appropriate propset ~Pset_AirTerminalBoxTypeCommon~,
but the ~description~ is not appropriate to that classification (an "AirTerminalBox" is not a "permit"!).

** Improve RDF Structure
:PROPERTIES:
:CUSTOM_ID: improve-rdf-structure
:END:
Overall, bSDD RDF represents the scope of bSDD data faithfully, although there are various omissions.

Also, there are various problems that should be corrected.
E.g. let's take the Turtle (RDF) fragment from the previous section:
#+begin_src turtle
<https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegmentCABLESEGMENT/ACResistance>
  bsdd:ClassificationProperty <https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegmentCABLESEGMENT>;
  bsdd:PropertyDomainName "IFC";
  bsdd:PropertyNamespaceUri "https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/prop/ACResistance".
#+end_src

It has these defects:
- No class is defined for the subject
- Prop names should start with lowercase
- String attributes should be converted to relations when applicable
- URLs should be object properties instead of strings

This fragment can be corrected as follows:
#+begin_src turtle
<https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegmentCABLESEGMENT/ACResistance>
  a bsdd:ClassificationProperty;
  bsdd:classification <https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegmentCABLESEGMENT>;
  bsdd:domain <https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3>;
  bsdd:property <https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/prop/ACResistance>.
#+end_src


** Use Class Inheritance
:PROPERTIES:
:CUSTOM_ID: use-class-inheritance
:END:
The following classes are very similar.
Many of the same fields are copied between them, with no modularity or inheritance:
- ~Property~ and ~ClassificationProperty~: we need to add some sort of relation or inheritance between them
- ~PropertyValue~ and ~ClassificationPropertyValue~: in fact are the same.
  These are "value objects" (simple immutable objecst), so there's absolutely no need to have two different classes

~Property~ is a general property definition, while ~ClassificationProperty~ is a property defined (or modified) locally to a ~Classification~.
TODO

** Add More Classes and Relations
:PROPERTIES:
:CUSTOM_ID: add-more-classes-and-relations
:END:
- PropertySet
- DomainVersion
- CountrySubdivision



** Add GraphQL Pagination
:PROPERTIES:
:CUSTOM_ID: add-graphql-pagination
:END:

** Improve GraphQL Searchability
:PROPERTIES:
:CUSTOM_ID: improve-graphql-searchability
:END:

** Eliminate Parallel Links Between Classes
:PROPERTIES:
:CUSTOM_ID: eliminate-parallel-links-between-classes
:END:

** Improve Multilingual Support
:PROPERTIES:
:CUSTOM_ID: improve-multilingual-support
:END:
bSDD accommodates multiple languages, but each domain seems to be present in one language only.

** Deprecated Properties
:PROPERTIES:
:CUSTOM_ID: deprecated-properties
:END:

** Improve the Description of Structured Values
:PROPERTIES:
:CUSTOM_ID: improve-the-description-of-structured-values
:END:

~ClassificationPropertyValue~ are structured values with rich fields: ~code, value, namespaceUri, description, sortNumber~.
These fields allow:
- unique identification of values through ~namespaceUri~
- potentially multilingual translations in the future (if ~value, description~ are made multivalued and attached a language tag)
- logical ordering of values through ~sortNumber~ (as opposed to always alphabetical ordering)
However, all structured values we've seen only ever have ~code, value~ and the other fields are null.

For example, the property ~ArrangementType~ in classification [[https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcAirTerminalBox][IfcAirTerminalBox]] has values described like this:
#+begin_src json
      "code": "DUALDUCT",
      "value": "DUALDUCT"
#+end_src

Value descriptions are intermingled with the property description (newline-separated) like this:
#+begin_src json
      "name": "ArrangementType",
      "description": "Terminal box arrangement.\n\
SingleDuct: Terminal box receives warm or cold air from a single air supply duct.\n\
DualDuct: Terminal box receives warm and cold air from separate air supply ducts.",
#+end_src

The "standard" values (NOTKNOWN, OTHER, UNSET) are not described at all.

Value URLs are missing, precluding unique identification.

** Better Representation of Predefined Values
:PROPERTIES:
:CUSTOM_ID: better-representation-of-predefined-values
:END:

~allowedValues~ (and its deprecated variant ~possibleValues~) store Structured Values (~ClassificationPropertyValue~).
However, their "sibling" property ~predefinedValue~ holds a mere string and not a Structured Value.
This means that even in the future, ~predefinedValue~ cannot be an enumeration value that is identified globally with a URL.
We could think of two possible reasons for this discrepancy:
- ~predefinedValue~ needs to hold not just enumeration values, but also Real, String, Boolean etc.
  However, then it should be structured as a variant, and not cast down into a String.
- It may be related to the poor description of Structured Values (see the previous section):

* Implementing Improvements
:PROPERTIES:
:CUSTOM_ID: implementing-improvements
:END:

We implemented a lot (but not all) of the improvements suggested above by using the following process:
- Fetching bSDD data as JSON
- Converting it to RDF using [[https://sparql-anything.cc/][SPARQL Anything]]
- Loading it to [[https://www.ontotext.com/products/graphdb/][GraphDB]]
- Refactoring the RDF using SPARQL Update
- TODO

** Fetching bSDD GraphQL JSON
:PROPERTIES:
:CUSTOM_ID: fetching-bsdd-graphql-json
:END:
Although bSDD is available in RDF, we decided to fetch all data in GraphQL JSON due to the RDF defects described above.

TODO Misho

** Converting JSON to Raw RDF using SPARQL Anything
:PROPERTIES:
:CUSTOM_ID: converting-json-to-raw-rdf-using-sparql-anything
:END:
In the next step we convert the JSON files to RDF.
We used the [[https://sparql-anything.cc/][SPARQL Anything]] tool (see [[https://sparql-anything.readthedocs.io/][documentation]]) that can convert various data formats to RDF by using SPARQL queries.

We developed two scripts:
- [[./scripts/rdfize.sparql][rdfize.sparql]] rdfizes one file. Parameter:
  - ~-v file~: file (local) or URL
- [[./scripts/rdfize-zip.sparql][rdfize-zip.sparql]] rdfizes an archive (zip) of files. Parameters:
  - ~-v zip~: zip filename or URL
  - ~-v file~: file regexp pattern (default ~.*~)

You can invoke the scripts like this:
: java -jar sparql-anything.jar -q rdfize.sparql    -v file=bSDD/ifc-4.3/IfcCableSegmentCABLESEGMENT.json
: java -jar sparql-anything.jar -q rdfize-zip.sparql -v zip=bSDD/ifc-4.3.zip -v file=IfcCableSegmentCABLESEGMENT.json

We explain the more complex script (~rdfize-zip.sparql~) below:
#+begin_src sparql
prefix bsdd: <http://bsdd.buildingsmart.org/def#>
prefix xyz:  <http://sparql.xyz/facade-x/data/>
prefix fx:   <http://sparql.xyz/facade-x/ns/>
prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix xsd:  <http://www.w3.org/2001/XMLSchema#>

construct {
  ?s ?p ?o
} where {
  service <x-sparql-anything:> {
    bind(coalesce(?__file,".*") as ?pattern)
    fx:properties fx:location ?_zip.
    fx:properties fx:archive.matches ?pattern.
    [] fx:anySlot ?file
    service <x-sparql-anything:media-type=application/json> {
      bind(str(bsdd:) as ?bsdd)
      fx:properties fx:namespace ?bsdd.
      fx:properties fx:location ?file.
      fx:properties fx:from-archive ?_zip.
      fx:properties fx:use-rdfs-member true.
      ?s ?p ?o
    }
  }
}
#+end_src

We use the simplest case of SPARQL Anything to convert JSON to RDF:
  : construct {?s ?p ?o} where {?s ?p ?o}
- The Raw RDF has similar form to the JSON, see next section
- It is possible to write more complex queries to drill down into the RDF structure, but we preferred to refactor RDF using SPARQL Update, see the section after next
- SPARQL Anything uses the prefix ~fx:~ for its features and functions.
- We define the ~bsdd:~ ontology namespace same as the existing bSDD RDF data.
- SPARQL Anything uses prefix ~xyz:~ to emit the output data.
  However, we use ~fx:properties fx:namespace~ to cast the data to the ~bsdd:~ namespace, so we don't use the ~xyz:~ prefix.
  The argument of this parameter is a string, so we use ~bind(str(bsdd:) as ?bsdd)~ to convert the respective namespace URL to a string
- We use the option ~fx:properties fx:use-rdfs-member true~ to emit JSON array members as multiple values of ~rdfs:member~ rather than the predicates ~rdf:_1, rdf:_2 ...~

All other lines of the script take care of handling input.
- We use command-line parameters to pass ([[https://sparql-anything.readthedocs.io/en/latest/#query-templates-and-variable-bindings-cli-only][variable bindings to the SPARQL Anything CLI)]].
  It uses the [[https://github.com/basilapi/basil/wiki/SPARQL-variable-name-convention-for-WEB-API-parameters-mapping][BASIL convention for variable names in queries]]:
  ~?_zip~ is a mandatory param, and ~?__file~ is an optional param
- The outer ~service~ invocation opens the zip archive:
  - Provides a default value for ~?__file~ by using ~coalesce~
  - Opens the ~?_zip~ archive using ~fx:location~
  - Uses ~fx:archive.matches~ to find all filenames that match ~?pattern~
  - The result is a list that we parse out by using ~fx:anySlot~ and feed it as multiple bindings to the variable ~?file~
- The inner ~service~ invocation opens the respective files from the zip archive:
  - Now we set ~fx:location~ to the filename found in the archive
  - And we use [[https://sparql-anything.readthedocs.io/en/latest/Configuration/#from-archive][fx:from-archive]] to open the archive again, and to read the file

*** Raw JSON Example
:PROPERTIES:
:CUSTOM_ID: raw-json-example
:END:
Take for example a classification in JSON obtained with the following command (shortened for brevity):
: curl -s https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegment | jq . > class-IfcCableSegment-orig1.json
#+begin_src json
{
  "referenceCode": "IfcCableSegment",
  "parentClassificationReference": {
    "namespaceUri": "https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcFlowSegment",
    "name": "IfcFlowSegment",
    "code": "IfcFlowSegment"
  },
  "classificationProperties": [
    {
      "name": "InstallationMethodFlagEnum",
      "description": "Special installation conditions relating to particular types of installation based on IEC60364-5-52:2001 reference installation methods C and D.",
      "dataType": "String",
      "possibleValues": [
        {
          "code": "BELOWCEILING",
          "value": "BELOWCEILING"
        }
      ],
      "propertyCode": "InstallationMethodFlagEnum",
      "propertyDomainName": "IFC",
      "propertyNamespaceUri": "https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/prop/InstallationMethodFlagEnum",
      "propertySet": "Pset_CableSegmentOccurrence",
      "propertyStatus": "Active",
      "propertyValueKind": "Single"
    },
  ],
  "domainNamespaceUri": "https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3",
  "activationDateUtc": "2022-12-31T00:00:00",
  "code": "IfcCableSegment",
  "countriesOfUse": [],
  "definition": "A cable segment is a flow segment used to carry electrical power, data, or telecommunications signals...",
  "name": "IfcCableSegment",
  "namespaceUri": "https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegment",
  "replacedObjectCodes": [],
  "replacingObjectCodes": [],
  "status": "Preview",
  "subdivisionsOfUse": [],
  "versionDateUtc": "2022-12-31T00:00:00"
}
#+end_src

The JSON representation obtained from the GraphQL API is very similar but not identical:
- We include ~__typename~ for each node to help assigning ~rdf:type~ later
- All fields are present, even when they are ~null~
- GraphQL fields are sometimes named differently (eg ~properties~ instead of ~classificationProperties~)
- There are some other differences
Eg see ~class-IfcCableSegment-orig.json~ (shortened for brevity):
#+begin_src json
{
  "namespaceUri": "https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegment",
  "__typename": "Classification",
  "classificationType": "CLASS",
  "relatedIfcEntityNames": [],
  "synonyms": [],
  "referenceCode": "IfcCableSegment",
  "properties": [
    {
      "namespaceUri": "https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/prop/InstallationMethodFlagEnum",
      "__typename": "ClassificationProperty",
      "allowedValues": [
        {
          "namespaceUri": null,
          "__typename": "ClassificationPropertyValue",
          "code": "BELOWCEILING",
          "description": null,
          "value": "BELOWCEILING",
          "sortNumber": null
        },
      ],
      "dataType": "String",
      "description": "Special installation conditions relating to particular types of installation based on IEC60364-5-52:2001 reference installation methods C and D.",
      "dimension": null,
      "dimensionLength": null,
      "dimensionMass": null,
      "dimensionTime": null,
      "dimensionElectricCurrent": null,
      "dimensionThermodynamicTemperature": null,
      "dimensionAmountOfSubstance": null,
      "dimensionLuminousIntensity": null,
      "dynamicParameterPropertyCodes": null,
      "example": null,
      "isDynamic": false,
      "isRequired": null,
      "isWritable": null,
      "maxExclusive": null,
      "maxInclusive": null,
      "methodOfMeasurement": null,
      "minExclusive": null,
      "minInclusive": null,
      "pattern": null,
      "physicalQuantity": null,
      "predefinedValue": null,
      "propertySet": "Pset_CableSegmentOccurrence",
      "propertyValueKind": "SINGLE",
      "symbol": null,
      "units": null,
      "activationDateUtc": "2022-12-31T00:00:00",
      "code": "InstallationMethodFlagEnum",
      "creatorLanguageCode": null,
      "countriesOfUse": null,
      "countryOfOrigin": null,
      "deActivationDateUtc": null,
      "definition": null,
      "deprecationExplanation": null,
      "documentReference": null,
      "name": "InstallationMethodFlagEnum",
      "replacedObjectCodes": null,
      "replacingObjectCodes": null,
      "revisionDateUtc": null,
      "revisionNumber": null,
      "status": "Active",
      "subdivisionsOfUse": null,
      "uid": null,
      "versionDateUtc": "2022-12-31T00:00:00",
      "versionNumber": null,
      "visualRepresentationUri": null
    },
  ],
  "relations": [],
  "childs": null,
  "activationDateUtc": "2022-12-31T00:00:00",
  "code": "IfcCableSegment",
  "creatorLanguageCode": null,
  "countriesOfUse": null,
  "countryOfOrigin": null,
  "deActivationDateUtc": null,
  "definition": "A cable segment is a flow segment used to carry electrical power, data, or telecommunications signals...",
  "deprecationExplanation": null,
  "documentReference": null,
  "name": "IfcCableSegment",
  "replacedObjectCodes": null,
  "replacingObjectCodes": null,
  "revisionDateUtc": null,
  "revisionNumber": null,
  "status": "Preview",
  "subdivisionsOfUse": null,
  "uid": null,
  "versionDateUtc": "2022-12-31T00:00:00",
  "versionNumber": null,
  "visualRepresentationUri": null
}

#+end_src

*** Raw RDF Example
:PROPERTIES:
:CUSTOM_ID: raw-rdf-example
:END:
The example GraphQL JSON is converted to the following "raw" RDF (shortened for brevity).
As you can see the structure is very similar, with empty blank nodes in various places, strings instead of URLs, etc.

#+begin_src turtle
@prefix bsdd: <http://bsdd.buildingsmart.org/def#> .
@prefix fx:   <http://sparql.xyz/facade-x/ns/> .
@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd:  <http://www.w3.org/2001/XMLSchema#> .
@prefix xyz:  <http://sparql.xyz/facade-x/data/> .

[ rdf:type                    fx:root ;
  bsdd:__typename             "Classification" ;
  bsdd:activationDateUtc      "2022-12-31T00:00:00" ;
  bsdd:classificationType     "CLASS" ;
  bsdd:code                   "IfcCableSegment" ;
  bsdd:definition             "A cable segment is a flow segment used to carry electrical power, data, or telecommunications signals..." ;
  bsdd:name                   "IfcCableSegment" ;
  bsdd:namespaceUri           "https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegment" ;
  bsdd:properties [
    rdfs:member  [ 
    bsdd:__typename         "ClassificationProperty" ;
    bsdd:activationDateUtc  "2022-12-31T00:00:00" ;
    bsdd:allowedValues [
      rdfs:member  [
      bsdd:__typename  "ClassificationPropertyValue" ;
      bsdd:code        "BELOWCEILING" ;
      bsdd:value       "BELOWCEILING"
    ]] ;
    bsdd:code               "InstallationMethodFlagEnum" ;
    bsdd:dataType           "String" ;
    bsdd:description        "Special installation conditions relating to particular types of installation based on IEC60364-5-52:2001 reference installation methods C and D." ;
    bsdd:isDynamic          false ;
    bsdd:name               "InstallationMethodFlagEnum" ;
    bsdd:namespaceUri       "https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/prop/InstallationMethodFlagEnum" ;
    bsdd:propertySet        "Pset_CableSegmentOccurrence" ;
    bsdd:propertyValueKind  "SINGLE" ;
    bsdd:status             "Active" ;
    bsdd:versionDateUtc     "2022-12-31T00:00:00"
  ]] ;
  bsdd:referenceCode          "IfcCableSegment" ;
  bsdd:relatedIfcEntityNames  []  ;
  bsdd:relations              []  ;
  bsdd:status                 "Preview" ;
  bsdd:synonyms               []  ;
  bsdd:versionDateUtc         "2022-12-31T00:00:00"
] .
#+end_src

** Transforming RDF using SPARQL Update
:PROPERTIES:
:CUSTOM_ID: transforming-rdf-using-sparql-update
:END:

There are various things to fix in the Raw RDF.
We wrote the SPARQL Update script [[./scripts/transform.ru][transform.ru]] (~.ru~ is teh W3C standard extension for this type of file).
It does the following:
- Cut out fractional seconds from date-times, and add datatype ~xsd:dateTime~
  - This pertains to ~activationDateUtc deActivationDateUtc revisionDateUtc versionDateUtc~
  - ~lastUpdatedUtc~ has overly-specific timestamps to the precision of 10e-7 seconds, eg ~2022-12-21T08:24:16.8080608~.
    We cut out the fractional part of seconds because the GraphQL scalar type ~DateTime~ as currently implemented in the Ontotext Platform doesn't support such precision
    (nor do we see any business need for it),
  - However, XSD allows any number of digits in the [[https://www.w3.org/TR/xmlschema11-2/#nt-seFrag][decimal part of seconds]],
    so we have posted an enhancement request [[https://ontotext.atlassian.net/browse/PLATFORM-4728][(PLATFORM-4728)]] to allow this. 
- Convert strings to URIs, and shorten props as appropriate
  - This pertains to all props called ~*Uri~, and the following are shortened:
| full                               | short                     | comment                                                                                |
|------------------------------------+---------------------------+----------------------------------------------------------------------------------------|
| bsdd:domainNamespaceUri            | bsdd:domain               | We point to the ~Domain~ not to its Uri                                                |
| bsdd:relatedClassificationUri      | bsdd:related              | We use the pair ~relation/related~ for both ~PropertyRelation, ClassificationRelation~ |
| bsdd:relatedPropertyUri            | bsdd:related              | We use the pair ~relation/related~ for both ~PropertyRelation, ClassificationRelation~ |
| bsdd:parentClassificationReference | bsdd:parentClassification | We point to the parent ~Classification~, so "reference" is parasitic                   |

- Drop redundant info of a referenced resource
  - Eg inside ~parentClassificationReference~, the props ~code, name~ are dropped
    because they are defined in the master record of that classification,
    thus are redundant in the reference
- Drop deprecated property ~bsdd:possibleValues~, since ~bsdd:allowedValue~ is used instead
- Multi-valued props: skip a level (~rdfs:member~) and change prop name to singular:
  - ~bsdd:objects [rdfs:member [...], [...]]~
  - Becomes ~bsdd:object [...], [...]~
  - Empty lists like ~bsdd:replacedObjectCodes []~ above disappear altogether, since that blank node representing the empty list is useless
- Short-cut the property path ~bsdd:parentClassificationReference/bsdd:namespaceUri~ to just ~bsdd:parentClassification~
- Add ~rdf:type~ based on GraphQL ~__typename~
  - Eg ~"__typename": "Domain"~ becomes ~rdf:type bsdd:Domain~
  - However, ~"__typename": "ClassificationPropertyValue"~ becomes ~rdf:type bsdd:PropertyValue~
    because the GraphQL class ~ClassificationPropertyValue~ is exactly the same as ~PropertyValue~
- Drop parasitic ~rdf:type fx:root~
- Rename ~ClassificationProperty.namespaceUri~ to ~ClassificationProperty.property~ because that link refers to a ~Property~ specifically
- Add meaningful URIs to blank nodes whenever possible. In particular:
  - ~ClassificationProperty~ gets URI: ~Classification.uri+"/"+propertyCode~ (here ~+~ indicates concatenation)
  - ~ClassificationPropertyValue~ gets URI: ~Classification.uri+"/"+ClassificationProperty.propertyCode +"/"+value~.
    This class has ~namespaceUri~, but that is optional and is almost never filled
  - ~PropertyValue~ gets URI: ~Classification.uri+"/"+Property.propertyCode +"/"+value~.
    This class has ~namespaceUri~, but that is optional and is almost never filled
- The following remain blank nodes:
  - ~ReferenceDocument~: no id field (only ~name, title, date~)
  - ~ClassificationRelation~: is just a pair of ~related~ Properties, no own URI
  - ~PropertyRelation~: is just a pair of ~related~ Properties, no own URI
- Remove redundant ~namespaceUri~ when equal to the node's URI
- Link domains with their classifications based on their IRIs

This SPARQL Update script is class-independent (works on any Raw bSDD RDF), so it can be used in two ways:
- On an individual RDF file by using Jena's ~update~, for testing
- After loading all data to [[https://www.ontotext.com/products/graphdb/][GraphDB]], to transform all of it in one go

*** Original RDF Example
:PROPERTIES:
:CUSTOM_ID: original-rdf-example
:END:
Now let's take a look at the original bSDD RDF ~class-IfcCableSegment-orig.ttl~ obtained with the following (shortened for brevity):
: curl -s -Haccept:text/turtle https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegment > class-IfcCableSegment-orig.ttl
#+begin_src turtle
@base <https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegment>.

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
@prefix xsd: <http://www.w3.org/2001/XMLSchema#>.
@prefix bsdd: <http://bsdd.buildingsmart.org/def#>.
@prefix qudtUnit: <http://qudt.org/vocab/unit/>.
@prefix ifc4_3: <https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3>.

<https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegment>
  bsdd:ActivationDateUtc "2022-12-31";
  bsdd:Code "IfcCableSegment";
  bsdd:Definition "A cable segment is a flow segment used to carry electrical power, data, or telecommunications signals...";
  bsdd:Domain ifc4_3:;
  bsdd:Name "IfcCableSegment";
  bsdd:ReferenceCode "IfcCableSegment";
  bsdd:Status "Preview";
  bsdd:VersionDateUtc "2022-12-31";
  a bsdd:Classification.

<https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegment/InstallationMethodFlagEnum>
  bsdd:ClassificationProperty <https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegment>;
  bsdd:DataType "String";
  bsdd:Description "Special installation conditions relating to particular types of installation based on IEC60364-5-52:2001 reference installation methods C and D.";
  bsdd:Name "InstallationMethodFlagEnum";
  bsdd:PropertyCode "InstallationMethodFlagEnum";
  bsdd:PropertyDomainName "IFC";
  bsdd:PropertyNamespaceUri "https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/prop/InstallationMethodFlagEnum";
  bsdd:PropertySet "Pset_CableSegmentOccurrence";
  bsdd:PropertyStatus "Active";
  bsdd:PropertyValueKind "Single".
#+end_src
It has numerous problems:
- RDF naming conventions are not followed (prop names are in uppercase)
- Classification Properties don't have ~rdf:type bsdd:ClassificationProperty~
- The relation from Classification Property to Classification is in the wrong direction
  (or should be renamed from ~bsdd:ClassificationProperty~ to ~bsdd:classification~)
- ~bsdd:PropertyNamespaceUri~ should be a URL (object property) instead of string (datatype property)
  and should be called ~bsdd:property~
- Dates (eg ~"2022-12-31"~) are rendered differently from JSON (have no timestamp), and lack appropriate datatype
- ~allowedValues~ and the respective ~ClassificationPropertyValue~ are missing altogether 

*** Refactored RDF Example
:PROPERTIES:
:CUSTOM_ID: refactored-rdf-example
:END:
After applying the transformation in sec [[*Transforming RDF using SPARQL Update]], we get the following refactored RDF ~class-IfcCableSegment-refact.ttl~ (shortened for brevity).
Compare it to both the original RDF (sec [[*Original RDF Example]]) and the raw RDF (sec [[*Raw RDF Example]]):
#+begin_src turtle
@prefix bsdd: <http://bsdd.buildingsmart.org/def#> .
@prefix fx:   <http://sparql.xyz/facade-x/ns/> .
@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd:  <http://www.w3.org/2001/XMLSchema#> .
@prefix xyz:  <http://sparql.xyz/facade-x/data/> .

<https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegment>
  rdf:type                     bsdd:Classification ;
  bsdd:activationDateUtc       "2022-12-31T00:00:00"^^xsd:dateTime ;
  bsdd:classificationProperty  <https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegment/InstallationMethodFlagEnum>, ... ;
  bsdd:classificationType      "CLASS" ;
  bsdd:code                    "IfcCableSegment" ;
  bsdd:definition              "A cable segment is a flow segment used to carry electrical power, data, or telecommunications signals..." ;
  bsdd:name                    "IfcCableSegment" ;
  bsdd:referenceCode           "IfcCableSegment" ;
  bsdd:status                  "Preview" ;
  bsdd:versionDateUtc          "2022-12-31T00:00:00"^^xsd:dateTime .

<https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegment/InstallationMethodFlagEnum>
  rdf:type                bsdd:ClassificationProperty ;
  bsdd:activationDateUtc  "2022-12-31T00:00:00"^^xsd:dateTime ;
  bsdd:allowedValue       <https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegment/InstallationMethodFlagEnum/BELOWCEILING> , ... ;
  bsdd:code               "InstallationMethodFlagEnum" ;
  bsdd:dataType           "String" ;
  bsdd:description        "Special installation conditions relating to particular types of installation based on IEC60364-5-52:2001 reference installation methods C and D." ;
  bsdd:isDynamic          false ;
  bsdd:name               "InstallationMethodFlagEnum" ;
  bsdd:property           <https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/prop/InstallationMethodFlagEnum> ;
  bsdd:propertySet        "Pset_CableSegmentOccurrence" ;
  bsdd:propertyValueKind  "SINGLE" ;
  bsdd:status             "Active" ;
  bsdd:versionDateUtc     "2022-12-31T00:00:00"^^xsd:dateTime .

<https://identifier.buildingsmart.org/uri/buildingsmart/ifc-4.3/class/IfcCableSegment/InstallationMethodFlagEnum/BELOWCEILING>
  rdf:type    bsdd:PropertyValue ;
  bsdd:code   "BELOWCEILING" ;
  bsdd:value  "BELOWCEILING" .
#+end_src

* Acknowledgements
:PROPERTIES:
:CUSTOM_ID: acknowledgements
:END:
This work is part of the ACCORD project that has received funding from the European Union’s Horizon Europe research and innovation programme under grant agreement no. 101056973
TODO compare to [[https://vttgroup.sharepoint.com/:p:/r/sites/EU-projectpreparationDigitalpermitsandcompliancecheck/_layouts/15/Doc.aspx?sourcedoc=%7BB9913B35-D290-4391-9588-0322584EF3BC%7D&file=ACCORD_EAB_meeting_02-12-2022.pptx&action=edit&mobileredirect=true][this pres]].

All source code, scripts and example files are available as open source on Github: https://github.com/Accord-Project/bsdd/


* References
:PROPERTIES:
:CUSTOM_ID: references
:END:
TODO: proper bibliography using Zotero

- (Beetz 2014) Beetz, J., van den Braak, W., Botter, R., Zlatanova, S., de Laat, R. (2014). Interoperable data models for infrastructural artefacts – A novel IFC extension method using RDF vocabularies exemplified with quay wall structures for harbors. eWork and eBusiness in Architecture, Engineering and Construction, 135–140:
  https://repository.tudelft.nl/islandora/object/uuid:bb9a7dff-52c7-4aaf-a6b8-898432270620/datastream/OBJ
- (Oraskari 2021) Live Web Ontology for buildingSMART Data Dictionary, Bauinformatik 2021

